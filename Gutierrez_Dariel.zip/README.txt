CPP Monopoly board game
Overview
This project implements a circular linked list to recreate the popular board game monopoly.
Each node in the list represents a space on the monopoly board and stores it's information.
The main features of the program include,
inserting properties at the head, tail, or a specific position.
Deleting properties from the head, tail, or a specific position.
Searching for a property based on its name.
Displaying all properties in the circular linked list.
Basic operations like checking if the list is empty and counting the nodes in the list.
The program is written in C++ and can be executed from CLion

How to Run the Code
Prerequisites:
Have a working C++ compiler, no tools necessary,
Instructions:
Click on green hammer icon in Clion or  open terminal, manually build project with
"cmake .
make"
then excecute with
"./monopoly_board"
Operations
1.Insert at Head
Description: This method inserts a new node at the beginning.
Time Complexity:
Best case: O(1)
Worst case: O(n)
2. Insert at Tail
Description: This method inserts a new node at the end.
Time Complexity:
Best case: O(1)
Worst case: O(n)
3. Insert at Position
Description: Inserts a new node at a specific position in the list.
Time Complexity:
Best case: O(1)
Worst case: O(n)
4. Delete at Head
Description: Removes the node at the head.
Time Complexity:
Best case: O(1)
Worst case: O(n)
5. Delete at Tail
Description: Removes the node at the end.
Time Complexity:
Best case: O(1)
Worst case: O(n)
6. Delete at Position
Description: Removes the node at a specific position.
Time Complexity:
Best case: O(1)
Worst case: O(n)
7. Search
Description: Searches for node by property.
Time Complexity:
Best case: O(1)
Worst case: O(n)
8. Print List
Description: Traverses through list and prints nodes.
Time Complexity:
Best case: O(1)
Worst case: O(n)
9. Print Head Node
Description: Prints head node.
Time Complexity:
Best case: O(1)
10. Print Last Node
Description: Prints last node.
Time Complexity:
Best case: O(1)
Worst Case: O(n)
11.Is List Empty
Description: Checks if the list is empty.
Time Complexity:
Best case: O(1)
12. Count Nodes
Description: Traverses through list and counts nodes.
Time Complexity:
Best case: O(1)
Worst case: O(n)
13. Reverse Circular Linked List
Description: This method reverses the order of the nodes in the circular linked list.
Time Complexity:
Best case: O(n)
Worst case: O(n)
14.Sort Circular Linked List
Description: This method sorts the circular linked list.
Time Complexity:
Best case: O(n)
Worst case: O(n^2)